<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <meta name="robots" content="noindex">
  <meta name="googlebot" content="noindex">
  
  
  <meta name="generator" content="Hugo 0.69.2" />
  <meta name="author" content="Matthew Schlegel">

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,700%7cOpen&#43;Sans:400,400italic,700%7cRoboto&#43;Mono%25!%28EXTRA%20*hugolib.pageState=Page%28/braindump/reinforcement_learning_an_introduction.md%29%29">
  <link rel="stylesheet" href="/styles.css">
  
  <link rel="stylesheet" href="/css/header.css">
  
  <link rel="stylesheet" href="/css/img.css">
  
  <link rel="stylesheet" href="/css/braindump.css">
  
  <link rel="stylesheet" href="/css/post.css">
  

  

  

  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon/favicon-16x16.png">
  <link rel="manifest" href="/img/favicon/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://mkschleg.github.io/braindump/reinforcement_learning_an_introduction/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@mattschleg">
  <meta property="twitter:creator" content="@mattschleg">
  
  <meta property="og:site_name" content="Matthew Schlegel">
  <meta property="og:url" content="https://mkschleg.github.io/braindump/reinforcement_learning_an_introduction/">
  <meta property="og:title" content="Reinforcement Learning: An Introduction | Matthew Schlegel">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2020-08-12T14:01:58-06:00">
  <meta property="article:modified_time" content="2020-08-12T14:01:58-06:00">
  

  <title>Reinforcement Learning: An Introduction | Matthew Schlegel</title>

  

  
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']], 
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

</head>
<body>

<style type="text/css">
  
 
  
 
</style>

<div class="masthead-hero"></div>


<div id="main" role="main">
  <div class="sidebar sticky" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <div class="author-avatar">
    <a href="/">
      
      <img src="/img/me.jpg" alt="Matthew Schlegel" itemprop="image">
      
    </a>
  </div>
  <div class="author-content">
    <h3 class="author-name" itemprop="name">Matthew Schlegel</h3>
    <p class="author-bio" itemprop="description">Lover of Espresso; PhD student at Amii, RLAI and UofA; Works on how machines perceive their world.</p>
  </div>
  <div class="author-urls-wrapper">
    <ul class="author-urls social-icons" aria-hidden="true">
      <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
        <span itemprop="name">Edmonton, Alberta</span>
      </li>
      
      <li>
        <a itemprop="sameAs" href="//linkedin.com/in/mkschleg" target="_blank" rel="noopener noreferrer">
          <i class="fa fa-linkedin"></i>
          LinkedIn
        </a>
      </li>
      
      <li>
        <a itemprop="sameAs" href="//twitter.com/mattschleg" target="_blank" rel="noopener noreferrer">
          <i class="fa fa-twitter"></i>
          Twitter
        </a>
      </li>
      
      <li>
        <a itemprop="sameAs" href="//github.com/mkschleg" target="_blank" rel="noopener noreferrer">
          <i class="fa fa-github"></i>
          Github
        </a>
      </li>
      
    </ul>
    <ul class="author-urls social-icons" aria-hidden="true" style="margin-top:30px;">
      
      <li>
        <a itemprop="sameAs" href=/tags >
          <i class="fa fa-tag"></i>
          Tags
        </a>
      </li>
      
      <li>
        <a itemprop="sameAs" href=/collections >
          <i class="fa fa-folder"></i>
          Collections
        </a>
      </li>
      
    </ul>
  </div>
</div>

  <article class="page">
		<div class="page_container">
			<section class="page_content">
				<div class="navbar-hero">
  <nav>
    
    
    <a class="hover" href="/">Home</a>
    
    
    <a class="hover" href="/about">About</a>
    
    
    <a class="hover" href="/publications">Publications</a>
    
    
    <a class="hover" href="/post">Posts</a>
    
    
    <a class="hover" href=/braindump> BrainDump </a>
    
  </nav>
</div>

				<article class="post" itemscope itemtype="http://schema.org/Article">
  <div class="post-container">
    <h1 itemprop="name"><a href="https://mkschleg.github.io/braindump/reinforcement_learning_an_introduction/">Reinforcement Learning: An Introduction</a></h1>

    
      

<div class="post-metadata">

  <span class="post-date">
    
    <time datetime="2020-08-12 14:01:58 -0600 MDT" itemprop="datePublished dateModified">
      Aug 12, 2020
    </time>
  </span>

  

</div>

    

    <div class="post-style" itemprop="articleBody">
      
      <div class="ox-hugo-toc toc">
<div></div>
<div class="heading">Table of Contents</div>
<ul>
<li><a href="#chapter-1">Chapter 1</a></li>
<li><a href="#chapter-2">Chapter 2</a></li>
<li><a href="#sec:RLI:mdps">Finite Markov Decision Processes</a>
<ul>
<li><a href="#the-agent-environment-interface">The Agent-Environment Interface</a></li>
<li><a href="#goals-and-rewards">Goals and Rewards</a></li>
<li><a href="#returns-and-episodes">Returns and Episodes</a></li>
<li><a href="#unified-notation-for-episodic-and-continuing-tasks">Unified Notation for Episodic and Continuing Tasks</a></li>
<li><a href="#policies-and-value-functions">Policies and Value Functions</a></li>
<li><a href="#optimal-policies-and-optimal-value-functions">Optimal Policies and Optimal Value Functions</a></li>
<li><a href="#optimality-and-approximation">Optimality and Approximation</a></li>
</ul>
</li>
<li><a href="#dynamic-programming">Dynamic Programming</a>
<ul>
<li><a href="#policy-evaluation--prediction">Policy Evaluation (prediction)</a></li>
<li><a href="#policy-improvement">Policy Improvement</a></li>
<li><a href="#policy-iteration">Policy Iteration</a></li>
<li><a href="#value-iteration">Value Iteration</a></li>
<li><a href="#asynchronous-dynamic-programming">Asynchronous Dynamic Programming</a></li>
<li><a href="#generalized-policy-iteration">Generalized Policy Iteration</a></li>
<li><a href="#efficiency-of-dynamic-programming">Efficiency of Dynamic Programming</a></li>
</ul>
</li>
<li><a href="#monte-carlo-methods">Monte Carlo Methods</a>
<ul>
<li><a href="#monte-carlo-prediction">Monte Carlo Prediction</a></li>
<li><a href="#monte-carlo-estimation-of-action-values">Monte Carlo Estimation of Action Values</a></li>
<li><a href="#monte-carlo-control">Monte Carlo Control</a></li>
<li><a href="#monte-carlo-control-without-exploring-starts">Monte Carlo Control without Exploring Starts</a></li>
<li><a href="#off-policy-prediction-via-importance-sampling">Off-policy Prediction via Importance Sampling</a></li>
<li><a href="#incremental-implementation">Incremental Implementation</a></li>
<li><a href="#off-policy-monte-carlo-control">Off-policy Monte Carlo Control</a></li>
<li><a href="#discounting-aware-importance-sampling">Discounting-aware Importance Sampling</a></li>
<li><a href="#per-decision-importance-sampling">Per-decision Importance Sampling</a></li>
</ul>
</li>
<li><a href="#temporal-difference-learning">Temporal-Difference Learning</a>
<ul>
<li><a href="#td-prediction">TD Prediction</a></li>
<li><a href="#advantages-of-td-prediction-methods">Advantages of TD Prediction Methods</a></li>
<li><a href="#optimality-of-td--0">Optimality of TD(0)</a></li>
<li><a href="#sarsa-on-policy-td-control">Sarsa: On-policy TD Control</a></li>
<li><a href="#q-learning-off-policy-td-control">Q-learning: Off-policy TD Control</a></li>
<li><a href="#expected-sarsa">Expected Sarsa</a></li>
<li><a href="#maximization-bias-and-double-learning">Maximization Bias and Double Learning</a></li>
<li><a href="#games-afterstates-and-other-special-cases">Games Afterstates, and Other Special Cases</a></li>
</ul>
</li>
<li><a href="#chapter-7">Chapter 7</a></li>
<li><a href="#planning-and-learning-with-tabular-methods">Planning and Learning with Tabular Methods</a>
<ul>
<li><a href="#models-and-planning">Models and Planning</a></li>
<li><a href="#dyna-integrated-planning-acting-and-learning">Dyna: Integrated Planning, Acting, and Learning</a></li>
<li><a href="#when-the-model-is-wrong">When the Model Is Wrong</a></li>
<li><a href="#prioritized-sweeping">Prioritized Sweeping</a></li>
<li><a href="#expected-vs-dot-sample-updates">Expected vs. Sample Updates</a></li>
<li><a href="#trajectory-sampling">Trajectory Sampling</a></li>
<li><a href="#real-time-dynamic-programming">Real-time Dynamic Programming</a></li>
<li><a href="#planning-at-decision-time">Planning at Decision Time</a></li>
<li><a href="#heuristic-search">Heuristic Search</a></li>
<li><a href="#rollout-algorithms">Rollout Algorithms</a></li>
<li><a href="#monte-carlo-tree-search">Monte Carlo Tree Search</a></li>
</ul>
</li>
<li><a href="#on-policy-prediction-with-approximation">On-policy Prediction with Approximation</a>
<ul>
<li><a href="#value-function-approximation">Value-function Approximation</a></li>
<li><a href="#the-prediction-objective---bar-ve">The Prediction Objective (\(\bar{VE}\))</a></li>
<li><a href="#stochastic-gradient-and-semi-gradient-methods">Stochastic-gradient and Semi-gradient Methods</a></li>
<li><a href="#linear-methods">Linear Methods</a></li>
<li><a href="#feature-construction-for-linear-methods">Feature Construction for Linear Methods</a></li>
<li><a href="#selecting-step-size-parameters-manually">Selecting Step-Size Parameters Manually</a></li>
<li><a href="#nonlinear-function-approximation-artificial-neural-networks">Nonlinear Function Approximation: Artificial Neural Networks</a></li>
<li><a href="#least-squares-td">Least-Squares TD</a></li>
<li><a href="#memory-based-function-approximation">Memory-based Function Approximation</a></li>
<li><a href="#kernel-based-function-approximation">Kernel-based Function Approximation</a></li>
<li><a href="#looking-deeper-at-on-policy-learning-interest-and-emphasis">Looking Deeper at On-policy Learning: Interest and Emphasis</a></li>
</ul>
</li>
<li><a href="#chapter-10">Chapter 10</a></li>
<li><a href="#chapter-11">Chapter 11</a></li>
<li><a href="#sec:RLI:traces"><span class="org-todo todo TODO">TODO</span> Eligibility Traces</a></li>
<li><a href="#policy-gradient-methods">Policy Gradient Methods</a>
<ul>
<li><a href="#policy-approximation-and-its-advantages">Policy approximation and its advantages</a></li>
<li><a href="#the-policy-gradient-theorem">The Policy Gradient Theorem</a></li>
<li><a href="#reinforce">REINFORCE</a></li>
<li><a href="#actor-critic">Actor-critic</a></li>
<li><a href="#policy-gradient-for-continuing-problems">Policy Gradient for Continuing Problems</a></li>
<li><a href="#policy-parameterization-for-continuous-actions">Policy Parameterization for Continuous Actions</a></li>
</ul>
</li>
<li><a href="#chapter-14">Chapter 14</a></li>
<li><a href="#chapter-15">Chapter 15</a></li>
<li><a href="#chapter-16">Chapter 16</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<!--endtoc-->
<p>\( \newcommand{\states}{\mathcal{S}}
\newcommand{\actions}{\mathcal{A}}
\newcommand{\rewards}{\mathcal{R}}
\newcommand{\transition}{P}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\naturals}{\mathbb{N}}
\newcommand{\expected}{\mathbb{E}}
\newcommand{\by}{\times}
\newcommand{\partialderiv}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\defineq}{\stackrel{{\tiny\mbox{def}}}{=}}
\newcommand{\defeq}{\stackrel{{\tiny\mbox{def}}}{=}}
\newcommand{\eye}{\Imat}
\newcommand{\hadamard}{\odot}
\newcommand{\trans}{\top}
\newcommand{\inv}{{-1}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\Prob}{\mathbb{P}}
\newcommand{\avec}{\mathbf{a}}
\newcommand{\bvec}{\mathbf{b}}
\newcommand{\cvec}{\mathbf{c}}
\newcommand{\dvec}{\mathbf{d}}
\newcommand{\evec}{\mathbf{e}}
\newcommand{\gvec}{\mathbf{g}}
\newcommand{\hvec}{\mathbf{h}}
\newcommand{\lvec}{\mathbf{l}}
\newcommand{\mvec}{\mathbf{m}}
\newcommand{\nvec}{\mathbf{n}}
\newcommand{\pvec}{\mathbf{p}}
\newcommand{\qvec}{\mathbf{q}}
\newcommand{\rvec}{\mathbf{r}}
\newcommand{\svec}{\mathbf{s}}
\newcommand{\uvec}{\mathbf{u}}
\newcommand{\vvec}{\mathbf{v}}
\newcommand{\wvec}{\mathbf{w}}
\newcommand{\xvec}{\mathbf{x}}
\newcommand{\yvec}{\mathbf{y}}
\newcommand{\zvec}{\mathbf{z}}
\newcommand{\Amat}{\mathbf{A}}
\newcommand{\Bmat}{\mathbf{B}}
\newcommand{\Cmat}{\mathbf{C}}
\newcommand{\Dmat}{\mathbf{D}}
\newcommand{\Emat}{\mathbf{E}}
\newcommand{\Fmat}{\mathbf{F}}
\newcommand{\Imat}{\mathbf{I}}
\newcommand{\Pmat}{\mathbf{P}}
\newcommand{\Umat}{\mathbf{U}}
\newcommand{\Vmat}{\mathbf{V}}
\newcommand{\Wmat}{\mathbf{W}}
\newcommand{\Xmat}{\mathbf{X}}
\newcommand{\thetavec}{\boldsymbol{\theta}}
\newcommand{\muvec}{\boldsymbol{\mu}}
\newcommand{\sigmavec}{\boldsymbol{\sigma}}
\newcommand{\jacobian}{\mathbf{J}}
\)</p>
<dl>
<dt>tags</dt>
<dd><a href="/braindump/reinforcement_learning/">Reinforcement Learning</a></dd>
<dt>source</dt>
<dd><a href="http://www.incompleteideas.net/book/the-book-2nd.html">http://www.incompleteideas.net/book/the-book-2nd.html</a></dd>
</dl>
<h2 id="chapter-1">Chapter 1</h2>
<h2 id="chapter-2">Chapter 2</h2>
<h2 id="finite-markov-decision-processes-secrlimdps">Finite Markov Decision Processes {#sec:RLI:mdps}</h2>
<p>This chapter introduces the formal problem of finite Markov decision processes (finite MDPs). You can think of MDPs as the mathematically idealized form of reinforcement learning (while the former came much earlier in the development of mathematical models for decision processes and stochastic processes).</p>
<h3 id="the-agent-environment-interface">The Agent-Environment Interface</h3>
<p>The learner and decision maker is called the <em>agent</em>. The thing it interacts with, comprising everything outside the agent, is the <em>environment</em>. These two systems interact continually, the agent selecting actions and the environment responding to these action and presenting new situations to the agent. The environment also gives rise to the rewards, special observations that the agent seeks to maximize over time. More specifically, the agent and environment interact at each of a sequence of discrete time steps, \(t=0,1,2,3,\ldots\). At each step \(t\), the agent receives some representation of the environment&rsquo;s <em>state</em>, \(S_t \in \states\), and on that basis selects and <em>action</em>, \(A_t \in \actions(s)\). At step \(t+1\) the agent receives a numerical <em>reward</em>, \(R_{t+1} \in \rewards \subset \reals\) and a new state \(S_{t+1}\). The assumption is there exists some relationship between the agent&rsquo;s action and the environment&rsquo;s reaction. This gives rise to a <em>trajectory</em></p>
<p>\[S_0, A_0, R_1, S_1, A_1, R_2, S_2, A_2, R_3, \ldots\].</p>
<p>If the MDP is <em>finite</em> the states, actions, and rewards (\(\states\), \(\actions\), and \(\rewards\)) all have a finite number of elements. The random variables \(R_t\) and \(S_t\) have well defined discrete probability distributions dependent only on the preceding state and action</p>
<p>\[p(s&rsquo;, r | s, a) \defeq Pr\{S_t=s&rsquo;, R_t=r | S_{t-1}=s, A_{t-1} = a\} \quad \triangleright \text{forall } s&rsquo;,s\in\states, r\in \rewards, a\in\actions(s) \].</p>
<p>The function \(p: \states\times\rewards\times\states\times\actions\) defines the <em>dynamics</em> of the MDP.</p>
<h3 id="goals-and-rewards">Goals and Rewards</h3>
<p>A core axiom on which reinforcement learning stands is noted as the <em>reward hypothesis</em></p>
<blockquote>
<p>That all of what we mean by goals and purposes can be well thought of as the maximization of the expected value of the cumulative sum of a received scalar signal (called reward).</p>
</blockquote>
<aside>
  <aside></aside>
<p>This &ldquo;hypothesis&rdquo; is vacuous in my opinion. There are no useful tests which could draw out to a broader understanding of what it means for an agent to have a goal or purpose. I believe this hypothesis cannot be tested just from two ambiguous statements; &ldquo;what we mean by&rdquo; and &ldquo;well thought of&rdquo;; which make any counters impossible as the counter can be &ldquo;that isn&rsquo;t what we mean&rdquo; or &ldquo;we can still think of it as&rdquo;. It is much better phrased as an assumption or axiom, as long as goals and purposes are more fully described. It is annoying to have circuitous on this: &ldquo;what is the agent&rsquo;s goal&rdquo; well it is to maximize reward, &ldquo;what is the reward&rdquo; well it is a signal defining the goal.</p>
</aside>
<div class="question">
  <div></div>
<p>Why is the reward hypothesis a hypothesis and not an assumption or axiom.</p>
</div>
<h3 id="returns-and-episodes">Returns and Episodes</h3>
<p>The agent seeks to maximize the <em>expected return</em>, where the return, denoted \(G_t\), is defined as some specific function of the reward sequence. In the simplest case the return is</p>
<p>\[G_t \defeq R_{t+1} + R_{t+2} + R_{t+3} + \ldots + R_T\]</p>
<p>where \(T\) is thought of as the &ldquo;final&rdquo; time step, or end of an <em>episode</em>. Each episode ends in a <em>terminal state</em>.</p>
<p>We can also think of <em>continuing tasks</em> where there are no terminal states. Because there is no termination, the above sum will eventually diverge to infinity. <em>Discounting</em> is one way of limiting the sum to a finite number:</p>
<p>\[G_t \defeq \sum_{k=0}^{\infty} \gamma^k R_{t+k+1} \quad \text{for } 0\le\gamma&lt;1\].</p>
<p>We can define the return recursively</p>
<p>\[G_t \defeq R_{t+1} + \gamma G_{t+1} \quad \text{where } G_T = 0\].</p>
<p>Because this is an exponentially decayed function, if the reward is a constant +1 we can say:</p>
<p>\[G_t = \frac{1}{1-\gamma}\].</p>
<h3 id="unified-notation-for-episodic-and-continuing-tasks">Unified Notation for Episodic and Continuing Tasks</h3>
<p>We can define a return for both episodic and continuing tasks</p>
<p>\begin{equation} \label{eqn:RLI:return}
G_t \defeq \sum_{k=t+1}^T \gamma^{k-t-1}R_k
\end{equation}</p>
<p>Where either \(T=\infty\) <strong>or</strong> \(\gamma = 1\).</p>
<h3 id="policies-and-value-functions">Policies and Value Functions</h3>
<ul>
<li><em>value function</em>: an estimate of the expected return, and can be thought of as &ldquo;how good&rdquo;</li>
<li><em>policy</em>: a mapping from states to probabilities of selecting each possible action (\(\pi(a|s)\)).</li>
</ul>
<p>The <em>value function</em> of a state s while following policy \(\pi\) is</p>
<p>\begin{equation} \label{eqn:RLI:valuefunc}
v_{\pi}(s) \defeq \expected_{\pi}\left[G_{t} | S_{t}=s\right]=\expected_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1} | S_{t}=s\right], \text { for all } s \in \states.
\end{equation}</p>
<p>The value of a terminal state (if any exist) is always zero. We say the function \(v_\pi\) is the <em>state-value function for policy π</em>. Similarly, we define the <em>action-value function for policy π</em> as</p>
<p>\begin{equation} \label{eqn:RLI:actionvaluefunc}
q_{\pi}(s, a) \defeq \expected_{\pi}\left[G_{t} | S_{t}=s, A_{t}=a\right]=\expected_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1} | S_{t}=s, A_{t}=a\right].
\end{equation}</p>
<p>A fundamental property of value functions used throughout reinforcement learning and dynamic programming is that they satisfy recursive relationships (similar to equation <a href="#eqn:RLI:return">eqn:RLI:return</a>)! For any policy \(\pi\) and any state \(s\), the following consistency condition holds:</p>
<p>\begin{align}
v_{\pi}(s)
&amp;\defeq \mathbb{E}_{\pi}\left[G_{t} | S_{t}=s\right] \nonumber \\\<br>
&amp;=\expected_{\pi}\left[R_{t+1}+\gamma G_{t+1} | S_{t}=s\right] \nonumber \\\<br>
&amp;=\sum_{a} \pi(a | s) \sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right)\left[r+\gamma \expected_{\pi}\left[G_{t+1} | S_{t+1}=s^{\prime}\right]\right] \nonumber\\\<br>
&amp;=\sum_{a} \pi(a | s) \sum_{s^{\prime}, r} p\left(s^{\prime}, r | s, a\right)\left[r+\gamma v_{\pi}\left(s^{\prime}\right)\right], \quad \text { for all } s \in \mathcal{S} \label{eqn:RLI:bellman}
\end{align}</p>
<p>The recursive form defined in equation <a href="#eqn:RLI:bellman">eqn:RLI:bellman</a> is known as the <em>Bellman equation for \(v_\pi\)</em>. It expresses the relationship between the value of a state and the values of its successor states. The value function \(v_\pi\) is the unique solution to its Bellman equation.</p>
<h3 id="optimal-policies-and-optimal-value-functions">Optimal Policies and Optimal Value Functions</h3>
<p>Value functions define a partial ordering over policies. A policy π is defined to be better than or equal to another policy π&rsquo; if its expected return is greater than or equal to that of π&rsquo; for all states. More clearly, \(\pi\geq\pi&rsquo;\) iff \(v_\pi(s) \geq v_{\pi&rsquo;}(s)\) for all \(s\in\states\). We will denote all optimal policies by \(\pi_\star\). All optimal polices share the same value function</p>
<p>\begin{equation}
v_\star (s) \defeq \max_\pi v_\pi(s) \quad \text{for all } s\in\states.
\end{equation}</p>
<p>We can also define the <em>optimal action-value function</em></p>
<p>\begin{equation}
q_\star (s,a)\defeq \max_\pi q_\pi(s,a) \quad \text{for all } s\in\states, a\in\actions.
\end{equation}</p>
<p>We can also define a special Bellman equation for the optimal value function called the <em>Bellman optimality equation</em></p>
<p>\begin{align}
v_\star(s)  &amp;= \max_a \sum_{s&rsquo;,r} p(s&rsquo;, r | s, a) \left[r+\gamma v_\star(s&rsquo;)\right] \\\<br>
q_\star(s,a) &amp;= \sum_{s&rsquo;,r} p(s&rsquo;,r|s,a)\left[r+\gamma \max_{a&rsquo;}q_\star (s&rsquo;, a&rsquo;)\right]
\end{align}</p>
<p>For finite MDPs, the Bellman optimality equation has a unique solution independent of the policy. While we can explicitly solve the Bellman optimality equation, there are a number of assumptions that are rarely true in real world examples:</p>
<ol>
<li>we accurately know the dynamics of the environment</li>
<li>we have enough computational resources to complete the computation of the solution</li>
<li>the Markov property</li>
</ol>
<p>Many reinforcement learning methods can be clearly understood as approximately solving the Bellman equation, using actual experienced transitions in place of knowledge of the expected transitions.</p>
<h3 id="optimality-and-approximation">Optimality and Approximation</h3>
<p>We are forced to settle for an approximate solution to the Bellman equation. But this is ok. The online nature of reinforcement learning makes it possible to approximate optimal policies in ways that put more effort into learning to make good decisions for frequently encountered states, at the expense of less effort for infrequently encountered states. This is &ldquo;one key property&rdquo; that distinguishes reinforcement learning from other approaches to approximately solving MDPs.</p>
<h2 id="dynamic-programming">Dynamic Programming</h2>
<p><strong>Dynamic programming</strong> (DP) refers to a collection of algorithms that can be used to compute optimal policies given a <em>perfect model</em> of the environment as an MDP. These algorithms are of limited use to the full RL problem as they require a perfect model and have an immense up-front computational cost. These algorithms are still interesting theoretically, and provide a nice foundation to begin thinking about learning optimal policies. In this chapter, we will limit ourselves to finite MDPs. A key idea of DP, and of RL generally, is the use of value functions to organize and structure the search for good policies.</p>
<h3 id="policy-evaluation--prediction">Policy Evaluation (prediction)</h3>
<p><strong>Policy Evaluation</strong>: compute the state-value function \(v_\pi\) for an arbitrary policy \(\pi\). Also known as the prediction problem. Recall from Chapter 3:</p>
<p>\begin{align}
v_\pi(s) &amp;\defeq \expected_\pi[G_t | S_t=s] \nonumber\\\<br>
&amp;= \sum_{a}\pi(a|s)\sum_{s&rsquo;, r} p(s&rsquo;, r|s, a)[r+\gamma v_\pi(s&rsquo;)] \label{eqn:RLI:dp:valuefunc}
\end{align}</p>
<p>If the environment&rsquo;s dynamics are completely known, then \ref{eqn:RLI:dp:valuefunc} is a system of \(|\states|\) simultaneous linear equations in \(|\states|\) unknowns. This calculation is straightforward but tedious. For our purposes, iterative solution methods are most suitable. If \(v_0\) is chosen arbitrarily (except for any terminal states which must be 0), then we can iteratively solve for the value function</p>
<p>\begin{align*}
v_{k+1}(s) &amp;\defeq \expected_\pi[R_{t+1} + \gamma v_k(S_{t+1}) | S_t = s] \\\<br>
&amp; = \sum_{a}\pi(a|s)\sum_{s&rsquo;, r} p(s&rsquo;, r|s, a)[r+\gamma v_{k}(s&rsquo;)] \label{eqn:RLI:dp:iterative}
\end{align*}</p>
<p>The sequence of \(v_k\) can be shown to converge to \(v_\pi\) in general as \(k\rightarrow\infty\). This algorithm is called <em>iterative policy evaluation</em>. This algorithm can also be done in-place.</p>
<h3 id="policy-improvement">Policy Improvement</h3>
<p>Once we have a state value function \(v_\pi\), we would like to use it to find a better policy (if one exists). The most straightforward method is to construct an action value function</p>
<p>\[q_\pi(s,a) \defeq \expected[R_{t+1} + \gamma v_\pi(S_{t+1}) | S_t =s, A_t = a].\]</p>
<p>If \(q_\pi(s,a) &gt; v_\pi(s)\) then you can improve the policy \(\pi\) by selecting action \(a\) in state \(s\) and then following \(\pi\) elsewhere. This is a special case of the <em>policy improvement theorem</em>. Let π and π&rsquo; be any pair of deterministic policies such that</p>
<p>\[q_\pi(s, \pi&rsquo;(s)) \ge v_\pi(s) \quad \triangleright \quad \forall s \in \states\].</p>
<p>Then the policy π&rsquo; must be as good as, or better than π, meaning \(v_{\pi&rsquo;}(s) \ge v_\pi(s)\).</p>
<p>Instead of focusing on changing the policy at a a single state, we can improve the policy over all states simultaneously: \(\pi&rsquo; \defeq \argmax_a q_\pi(s,a)\).</p>
<h3 id="policy-iteration">Policy Iteration</h3>
<p>Once a policy π has been improved using \(v_\pi\) to yield a better policy π', we can then compute \(v_{\pi&rsquo;}\) and improve it again to yield an even better policy! We can create a chain of evaluations and improvements continuing until we get to a policy which is no longer changing. Because a finite MDP has only a finite number of policies, this process must converge to an optimal policy and optimal value function in a finite number of iterations. This is called <strong>policy iteration</strong>.</p>
<div class="algorithm">
  <div></div>
<p>\begin{algorithmic}
\State 1. Initialization
\State $V(s) \in \reals$ and $\pi(s) \in \actions(s)$ arbitrarily for $s\in\states$
\State
\State 2. Policy Evaluation
\Repeat
\State $\Delta \leftarrow 0$
\ForAll{$s \in \states$}
\State $v \leftarrow V(s)$
\State $V(s) \leftarrow \sum_{s&rsquo;,r}p(s&rsquo;,r|s,\pi(s)) [r+\gamma V(s&rsquo;)]$
\State $\Delta \leftarrow max(\Delta, |v-V(s)|)$
\EndFor
\Until{$\Delta &lt; \theta$}
\State
\State 3. Policy Improvement
\State $policy\_stable \leftarrow true$
\ForAll{$s\in\states$}
\State $old-action\leftarrow\pi(s)$
\State $\pi(s) \leftarrow \argmax_a \sum_{s&rsquo;,r}p(s&rsquo;,r|s,\pi(s)) [r+\gamma V(s&rsquo;)]$
\State If $old\_action \neq \pi(s)$, then $policy\_stable \leftarrow false$
\EndFor
\State If $policy\_stable$, then stop and return $V\approx v_\star$ and $\pi \approx \pi_\star$; else go to 2.
\end{algorithmic}</p>
<p>\caption{Policy Iteration (using iterative policy evaluation) for estimating $\pi \approx \pi^*$}</p>
</div>
<h3 id="value-iteration">Value Iteration</h3>
<p>Instead of having a full policy evaluation step in-between policy improvement steps, we can truncate policy evaluation to a single sweep through the state-space without changing the convergence properties of the algorithm. This algorithm is known as <em>value iteration</em> and can be written simply as</p>
<p>\[v_{k+1}(s) \defeq \max_a \sum_{s&rsquo;,r} p(s&rsquo;, r|s,a)[r+\gamma v_k(s&rsquo;)] \quad \triangleright \quad \forall s\in\states\].</p>
<p>Value iteration effectively combines one sweep of policy evaluation and one sweep of policy improvement. Faster convergence is often achieved by interposing multiple policy evaluation sweeps between each policy improvement sweep. In general, the entire class of truncated policy iteration algorithms can be through of as sequences of sweeps.</p>
<div class="algorithm">
  <div></div>
<p>\begin{algorithmic}
\State Algorithm parameter: a small threshold $\theta &gt; 0$ determining accuracy of estimation.
\State Initialize $V(s)$, for all $s\in\states^+$, arbitrarily except that $V(terminal)=0$
\Repeat
\State $\Delta \leftarrow 0$
\ForAll{$s\in\states$}
\State $v\leftarrow V(s)$
\State $V(s) \leftarrow \max_a \sum_{s&rsquo;,r} p(s&rsquo;, r|s,a)[r+\gamma V(s&rsquo;)]$
\State $\Delta \leftarrow \max(\Delta, |v-V(s)|)$
\EndFor
\Until{$\Delta &lt; \theta$}
\State Output a deterministic policy, $\pi \approx\pi_\star$, such that
\State $\pi(s) = \argmax_a \sum_{s&rsquo;,r} p(s&rsquo;, r|s,a)[r+\gamma V(s&rsquo;)]$
\end{algorithmic}</p>
<p>\caption{Value Iteration, for estimating $\pi\approx\pi^\star$}</p>
</div>
<h3 id="asynchronous-dynamic-programming">Asynchronous Dynamic Programming</h3>
<p><em>Asynchronous DP</em> algorithms: in-place iterative DP algorithms that are not organized in terms of systematic sweeps of the state set. These algorithms update the values of states in any order whatsoever, using whatever values of other states happen to be available. The only restriction for convergence is an asynchronous algorithm must continue to update the values of all the states.</p>
<h3 id="generalized-policy-iteration">Generalized Policy Iteration</h3>
<p><em>Generalized policy iteration</em> (GPI): the general idea of letting policy-evaluation and policy-improvement porcesses interact, independent of the granularity and other details of the two processes.</p>
<h3 id="efficiency-of-dynamic-programming">Efficiency of Dynamic Programming</h3>
<p>If \(n\) and \(k\) denote the number of states and actions, a DP method takes a number of computational operations that is less than some polynomial function of \(n\) and \(k\) (i.e. DP methods are in polynomial time). DP is sometimes through to be of limited applicability because of the <em>curse of dimensionality</em>, the fact that the number of states often grows exponentially with the number of state variables.</p>
<h2 id="monte-carlo-methods">Monte Carlo Methods</h2>
<p>Monte Carlo methods require only <em>experience</em>&ndash;sample sequences of states, action, and rewards from actual or simulated interaction with an environment. These methods are a way to solve the reinforcement learning problem based on averaging sample returns. In this section we will only go into Monte Carlo methods for episodic tasks, forgoing continuing tasks (discounting) entirely.</p>
<h3 id="monte-carlo-prediction">Monte Carlo Prediction</h3>
<p>A Monte Carlo method estimates a value for a particular state by averaging the returns of seen after the state is visited.</p>
<ul>
<li><em>first-visit</em> MC estimates \(v_\pi(s)\) as the average of the returns following first visits to \(s\).</li>
<li><em>every-visit</em> MC averages the returns following all visits to \(s\).</li>
</ul>
<p>Both the above methods are well known and converge to the optimal, albeit with slightly different theoretical properties. It is quite easy to see why first-visit converges (by the law of large numbers). Every-visit still converges quadratically, but is a bit more onerous (Singh 1996).</p>
<div class="algorithm">
  <div></div>
<p>\begin{algorithmic}
\State Input: a policy $\pi$ to be evaluated
\State Initialize: $V(s)\in\reals \forall s\in\states$, $Returns(s) \leftarrow$ empty list.
\ForAll{$e\in$Episodes}
\State Generate an episode following $\pi$: $S_0, A_0, R_1, S_1, A_1, R_2, \ldots, S_{T-1}, A_{T-1}, R_T$
\State $G \leftarrow 0$
\ForAll{$t \in \{T-1, T-2, \ldots, 0\}$}
\State $G\leftarrow \gamma G + R_{t+1}$
\If{$S_t \notin \{S_0, S_1, \ldots, S_{t-1}\}$}
\State Append $G$ to $Returns(S_t)$
\State $V(s_t) \leftarrow average(Returns(S_t))$
\EndIf
\EndFor
\EndFor
\end{algorithmic}</p>
<p>\caption{First-visit MC prediction, for estimating $V \approx v_\pi$}</p>
</div>
<aside>
  <aside></aside>
<p>According to (Singh 1996) every-visit Monte Carlo methods resolve to a TD update with accumulating traces, and first-visit Monte Carlo methods resolve to a TD update with replacing traces. This will become more clear when we discuss eligibility traces in section  <a href="#sec:RLI:traces">sec:RLI:traces</a>.</p>
</aside>
<h3 id="monte-carlo-estimation-of-action-values">Monte Carlo Estimation of Action Values</h3>
<p>Without a model of the environment, estimating state value functions is not enough to prepare behavior. Instead, one must estimate action-state value functions (as discussed in section <a href="#sec:RLI:mdps">sec:RLI:mdps</a>). The evaluation algorithm is very similar to that of state value functions. The one modification to the original algorithm is the need for the agent to explore (even when given a deterministic policy) to estimate the return for each action from every state.</p>
<h3 id="monte-carlo-control">Monte Carlo Control</h3>
<div class="algorithm">
  <div></div>
<p>\begin{algorithmic}
\State Initialize:
\State $\quad\pi(s) \in \actions(s)$ (arbitrarily)
\State $\quad Q(s,a) \in \reals$ (arbitrarily)
\State $\quad Returns(s,a) \leftarrow $ empty list.
\For{each episode}
\State Choose $S_0 \in \states, A_0 \in \actions(S_0)$ randomly from all states and actions
\State Generate an episode of length $T&gt;0$
\State $G \leftarrow 0$
\For{$t = \{T-1, T-2, \ldots, 0\}$}
\State $G \leftarrow \gamma G + R_{t+1}$
\If{$S_t, A_t \notin \{S_0, A_0, \ldots S_{t-1}, A_{t-1}\}$}
\State Append $G$ to $Returns(S_t, A_t)$
\State $Q(S_t, A_t) \leftarrow average(Returns(S_t, A_t))$
\State $\pi(S_t) \leftarrow \argmax_a Q(S_t, a)$
\EndIf
\EndFor
\EndFor
\end{algorithmic}</p>
<p>\caption{Monte Carlo ES (Exploring Starts), for estimating $\pi \approx \pi_*$}</p>
</div>
<h3 id="monte-carlo-control-without-exploring-starts">Monte Carlo Control without Exploring Starts</h3>
<p>In the case that the prior assumption of &ldquo;exploring starts&rdquo; is not met, the easiest way to fulfill the assumption that all actions are chosen infinitely often is for the agent to continue to select them. This section details an on-policy version of the above algorithm which accomplishes this, in the next section an off-policy method will be introduced.</p>
<p>In on-policy control the policy is generally soft (i.e. \(\pi(a | s) &gt; 0 \quad \forall s \in \states \text{ and } a \in \actions\) ) and gradually shifted to the deterministic optimal policy.</p>
<div class="note">
  <div></div>
<p>This Assumes there is an optimal deterministic policy, which depending on the problem setting may not be true. But this assumption is reasonable in the MDP setting as stated.</p>
</div>
<p>The on-policy method in this setting uses what are called $ε$-greedy policies. Effectively they assign probability \(1-\epsilon + \frac{\epsilon}{|\actions(s)|}\) to the action with the highest estimated value and \(frac{\epsilon}{|\actions(s)|}\) to the remaining values. While not shown here, one can find the sketch of a proof showing policy improvement works for $ε$-greedy policies in a similar way to deterministic policies w/ exploring starts in <a href="/braindump/reinforcement_learning_an_introduction/">(Sutton 2018)</a> page 101.</p>
<h3 id="off-policy-prediction-via-importance-sampling">Off-policy Prediction via Importance Sampling</h3>
<p>This section introduces the notion of learning from data which is generated from a policy which is different from the policy of interest (i.e. the optimal). These learning strategies are called off-policy.</p>
<ul>
<li><em>target</em> policy \(\pi\): The policy of interest.</li>
<li><em>behavior</em> policy \(b\): The policy used to act in the environment.</li>
</ul>
<p>In order to use experience generated from \(b\) to learn about policy \(\pi\) they must have shared support over the state action space (i.e. \(\pi(a|s) &gt; 0 \text{ implies } b(a|s) &gt; 0\)). The core of the algorithm comes in correcting the mismatch in distributions through what is called the <em>importance ratio</em> \(\rho(A, S) = \frac{\pi(A|S)}{b(A|S)}\) and over a trajectory \(\rho_{t:T-1} = \prod_{k=t}^{T-1} \rho(A_k | S_k)\). Importance sampling can then be applied to the expectation over returns to get the proper value function</p>
<p>\[
\expected [\rho_{t:T-1} G_t | S_t = s] = v_{\pi}(s).
\]</p>
<p>There are plenty of problems when applying importance ratios immediately to the problem. One of particular concern is that ordinary importance sampling can have infinite variance (depending on the problem), which leads to unstable slow learning. Other algorithms have been invented to handle the infinite variance issue (i.e. weighted importance sampling, resampling).</p>
<h3 id="incremental-implementation">Incremental Implementation</h3>
<p>The episode-by-episode incremental version of Monte Carlo prediction methods are straight forward taking the form:</p>
<p>\[
V_{n+1} = V_n + \frac{1}{n} [G_n - V_n].
\]</p>
<p>These can also be defined w/ OIS and WIS (see <a href="/braindump/reinforcement_learning_an_introduction/">(Sutton 2018)</a> page 109).</p>
<h3 id="off-policy-monte-carlo-control">Off-policy Monte Carlo Control</h3>
<p>This is a straightforward extension of the off-policy Monte Carlo prediction algorithms presented above to GPI.</p>
<h3 id="discounting-aware-importance-sampling">Discounting-aware Importance Sampling</h3>
<h3 id="per-decision-importance-sampling">Per-decision Importance Sampling</h3>
<h2 id="temporal-difference-learning">Temporal-Difference Learning</h2>
<h3 id="td-prediction">TD Prediction</h3>
<h3 id="advantages-of-td-prediction-methods">Advantages of TD Prediction Methods</h3>
<h3 id="optimality-of-td--0">Optimality of TD(0)</h3>
<h3 id="sarsa-on-policy-td-control">Sarsa: On-policy TD Control</h3>
<h3 id="q-learning-off-policy-td-control">Q-learning: Off-policy TD Control</h3>
<h3 id="expected-sarsa">Expected Sarsa</h3>
<h3 id="maximization-bias-and-double-learning">Maximization Bias and Double Learning</h3>
<h3 id="games-afterstates-and-other-special-cases">Games Afterstates, and Other Special Cases</h3>
<h2 id="chapter-7">Chapter 7</h2>
<h2 id="planning-and-learning-with-tabular-methods">Planning and Learning with Tabular Methods</h2>
<p>This chapter develops a unified view of reinforcement learning methods that require a model of the environment, such as dynamic programming and heuristic search, and methods that can be used without a model.</p>
<ul>
<li><em>model-free</em> methods: These methods are those discussed in the first 6 chapters of the book. Specifically Monte-carlo methods, TD methods, and similar such methods not requiring a model of the environment&rsquo;s dynamics.</li>
<li><em>model-based</em> methods: These methods deploy a type of <em>planning</em> for their main component for training value functions and policies. Dynamic programming can be considered as model-based in this context.</li>
</ul>
<h3 id="models-and-planning">Models and Planning</h3>
<p><strong>model</strong>: A model is a representation of the environment&rsquo;s dynamics. This can be a non-parametric model such as an experience replay buffer, or a parametric model generating sample transitions. You can also represent a model through predictions in the world (not discussed directly here), or through options in an option-model.</p>
<p>From the book: A model of the environment is anything that an agent can use to predict how the environment will respond to its actions.</p>
<ul>
<li><em>distribution models</em>: produce a description of all possibilities and their probabilities (<strong>type of model assumed by dynamic programming</strong>)</li>
<li><em>sample models</em>: produce just one of the possibilities sampled according to the probabilities.</li>
</ul>
<p>Distribution models are stronger than sample models as they can be used to produce samples, but these types of models are hard to learn/obtain.</p>
<p>We say the model is used to <em>simulate</em> the environment and produce <em>simulated experience</em>.</p>
<p><strong>planning</strong>: In this book, the term refers to any computational process that takes a model as input and produces or improves a policy for interacting with the modeled environment.</p>
<ul>
<li><em>State-space planning</em>: a search through the state space for an optimal policy or an optimal path to a goal.</li>
<li><em>Plan-space planning</em>: a search through the space of plans. These types of methods include evolutionary methods and &ldquo;partial-order planning&rdquo;</li>
</ul>
<p>The view taken in this book is that all state-space planning methods share a common structure, which is also present in the learning methods. There are two basic ideas to this view:</p>
<ol>
<li>all state-space planning methods involve computing value functions as a key intermediate step toward improving the policy</li>
<li>they compute value functions by updates applied to simulated experience.</li>
</ol>
<h3 id="dyna-integrated-planning-acting-and-learning">Dyna: Integrated Planning, Acting, and Learning</h3>
<p>There are at least two roles for real experience:</p>
<ul>
<li><em>Model-learning</em>: it can be used to improve the model</li>
<li><em>Direct RL</em>: it can be used to directly improve the value function and policy using and <em>model-free</em> method.</li>
</ul>
<p>When using simulated experience (from the model) to learn, this is called <em>indirect RL</em>.</p>
<p>Dyna-Q includes all of the above processes occuring continually. The planning method is the random-sample one-step tabular Q-planning method (simply sampling a transition from a model from a randomly chosen state action pair; see page 161 of <a href="/braindump/reinforcement_learning_an_introduction/">(Sutton 2018)</a>). The model-learning method is table-based and assumes the environment is deterministic (making this the least usable model learning approach beyond tabular domains).</p>
<p>They show an example of a maze comparing Q-learning (Dyna-Q with \(n=0\) planning steps), and Dyna-Q with \(n=\{5, 50\}\) planning steps. It quite clearly shows model-based methods working better than model-free methods, but this result can only be generalized to tabular settings. It is quite straightforward with a deterministic tabular environment, a model is accurate from basic experience. Unfortunately, such models are hard to learn/uncover.</p>
<h3 id="when-the-model-is-wrong">When the Model Is Wrong</h3>
<p>When the model is incorrect, the planning process is likely to compute a suboptimal policy. This is shown in the blocking maze experiment. Another method was introduced, Dyna-Q+, which introduces a heuristic (i.e. reward shaping and state counting) to determine when the environment might change, or when the agent should go and explore parts of the environment again. This is again not possible in larger environments, as model based learning is hard in such environments to achieve the fidelity needed to perform well.</p>
<p>Specifically the Dyna-Q+ algorithm keeps track of each state-action pair of how many time steps have elapsed since the pair was last tried in a real interaction with the environment. The indirect RL then set a reward for these samples as \(r + \kappa\sqrt{\tau}\), for a small set \(\kappa\). This would inject bias into the agent&rsquo;s policy to explore parts of the state-space not seen in a while.</p>
<p>This is fine with a finite state-space, but a state-space which is large this could cause the agent to do something bad. Also this assumes any change to the environment is good, which is a bold assumption.</p>
<h3 id="prioritized-sweeping">Prioritized Sweeping</h3>
<p>The main idea is that we want to plan backward from any state whose value has changed. This idea can be termed <em>backward focusing</em> of planning computations. Instead of uniformly sampling across all transitions which have changed values, we could prioritize on the <em>urgency</em> of the change (i.e. update the changes with the most impact first). This is implemented using a priority queue over state-action pairs.</p>
<p>This idea is easily extended to stochastic environments, and we can use similar ideas from Dyna-Q+ for non-stationary environments.</p>
<h3 id="expected-vs-dot-sample-updates">Expected vs. Sample Updates</h3>
<p>Expected updates take considerably more computation than sample updates. For instance consider the expectation update</p>
<p>\[ Q(s, a) \leftarrow \sum_{s^{\prime}, r} \hat{p}\left(s^{\prime}, r | s, a\right)\left[r+\gamma \max _{a^{\prime}} Q\left(s^{\prime}, a^{\prime}\right)\right] \]</p>
<p>and the corresponding sample update</p>
<p>\[ Q(s, a) \leftarrow Q(s, a)+\alpha\left[R+\gamma \max _{a^{\prime}} Q\left(S^{\prime}, a^{\prime}\right)-Q(s, a)\right]. \]</p>
<p>The expected updates consider all possible events taking the expectation over these events to get a cleaner update. The sample updates only consider a single sample from the environment, and implicitly do the expectation over several visits to this states local area. The computational differences is significant here. If a correct estimate of the transition dynamics is available, and there is roughly \(|\states \times \rewards|\) more computation available then the expected update would produce a better estimator.</p>
<p>They present a nice plot which illustrates why sample updates are better. In summary, the amount of computation needed to perform a expected update as above is incredibly large as the number of states and actions increases. The sample-updates almost definitely win in real world applications.</p>
<h3 id="trajectory-sampling">Trajectory Sampling</h3>
<p>This is a contrast to prior model based methods presented (specifically Dyna-Q), where a uniform sampling of the state-space was performed. This implicitly assigns equal computation to all states, which is undesirable. One alternative is trajectory based sampling, where the agent simulates a trajectory based on a randomly sampled state-action pair. This is ok, but also requires a model which can simulate such a trajectory (which is a really difficult ask).</p>
<p>Another approach that I can think of is through an ER buffer, where we are selecting states and action according to the desired distribution induced by the behavior. It is difficult to imagine every being able to sample according to the uniform policy in large scale problems, but given the toy examples the on-policy distribution seems to be the correct thing for faster learning.</p>
<h3 id="real-time-dynamic-programming">Real-time Dynamic Programming</h3>
<p>This is an example of an <em>asynchronous-DP</em> method. Here the update order is dictated by the order states are visited in real or simulated trajectories.</p>
<p><strong>Properties:</strong></p>
<ul>
<li>RTDP is guaranteed to find a policy that is optimal on the relevant states without visiting every state infinitely often, or even without visiting some states at all (in undiscounted episodic tasks for MDPs with absorbing goal states that generate zero rewards). This convergence happens with probability one when each episode begins in a randomly chosen state sampled from the set of start states and ending at the goal state.</li>
<li>As the value function approaches the optimal value function, the policy used by the agent to generate trajectories approaches an optimal policy because it is always greedy wrt the current value function.</li>
</ul>
<h3 id="planning-at-decision-time">Planning at Decision Time</h3>
<p><em>Background planning</em>: Planning to gradually improve the value function or policy on the basis of simulated experience obtained from a model. Selecting actions is then a matter of comparing the current state&rsquo;s action values. Planning is not focused on the current state.</p>
<p><em>Decision-time planning</em>: When planning is begun and completed <em>after</em> encountering each new state \(S_t\), as a computation whose output is the selection of a single action \(A_t\). Planning focuses on a particular state (i.e. the current state or those already visited).</p>
<h3 id="heuristic-search">Heuristic Search</h3>
<p>For each state encountered, a large tree of possible continuations is considered. The approximate value function is applied to the leaf nodes and then backed up toward the current state at the root.</p>
<h3 id="rollout-algorithms">Rollout Algorithms</h3>
<p>These algorithms are based on Monte Carlo control applied to simulated trajectories that all begin at the current environment state. They estimate action values for a given policy by averaging the returns of many simulated trajectories that start with each possible action and then follow the given policy. These algorithms were described by (Tesauro 1994) in their self-learning backgammon agent.</p>
<p>The goal of a rollout algorithm is to improve on the rollout policy, not to find the one-step optimal policy.</p>
<h3 id="monte-carlo-tree-search">Monte Carlo Tree Search</h3>
<p>This is an example of a rollout algorithm enhanced by the addition of a means for accumulating value estimates obtained from the Monte Carlo simulations in order to successively direct simulations toward more highly-rewarding trajectories.</p>
<ol>
<li><strong>Selection</strong> Starting at the root node, a <em>tree policy</em> based on the action values attached to the edges of the tree traverses the tree to select a leaf node.</li>
<li><strong>Expansion</strong> On some iterations, the tree is expanded from the selected leaf node by adding one or more child nodes reached from the selected node via unexplored actions.</li>
<li><strong>Simulation</strong> From the selected node, or from one of the added child nodes, simulation of a complete episode is run with actions selected by the rollout policy.</li>
<li><strong>Backup</strong> The return generated by the simulated episode is backed up to update, or initialize, the action values attached to the edges of the tree traversed by the tree policy. <strong>No values are saved for the states and actions visited by the rollout policy beyond the tree</strong>.</li>
</ol>
<h2 id="on-policy-prediction-with-approximation">On-policy Prediction with Approximation</h2>
<p>This chapter begins the study of function approximation in reinforcement learning, where the estimate of the value function \(v_\pi\) and policy \(\pi\) could be a parameterized functional with weight vector \(\wvec\in\reals^d\). \(\hat{v}(s,\wvec) \approx v_\pi(s)\). Typically the number of weights is much less than the number of states (\(d \ll |\states|\)).</p>
<h3 id="value-function-approximation">Value-function Approximation</h3>
<p>We will refer to an individual update by the notation \(s \mapsto u\) where \(s\) is the state updated, and \(u\) is the update target. For example,</p>
<ul>
<li>the Monte Carlo update for value prediction: \(S_t \mapsto G_t\),</li>
<li>the TD(0) update: \(S_t \mapsto R_{t+1} + \gamma\hat{v}(S_{t+1}, \wvec_t)\),</li>
<li>n-step TD update: \(S_t\mapsto G_{t:t+n}\).</li>
<li>DP policy-evaluation update: \(s\mapsto \expected_{\pi}[R_{t+1} + \gamma \hat{v}(S_{t+1}, \wvec_t) | S_t = s]\).</li>
</ul>
<h3 id="the-prediction-objective---bar-ve">The Prediction Objective (\(\bar{VE}\))</h3>
<p>The most obvious objective is the <em>Mean Squared Value Error</em> \(\overline{VE}\), where it is constructed as you would expect, except weighted by the state distribution induced by the behavior</p>
<p>\begin{equation} \label{eqn:RLI:VE}
\overline{VE}(\wvec) \defeq \sum_{s\in\states} \mu(s) \left[ v_{\pi}(s) - \hat{v}(s, \wvec) \right]^2
\end{equation}</p>
<p>The square root of this measure gives a rough measure of how much the approximate values differ from the true values and is often used in plots.</p>
<div class="tcolorbox">
  <div></div>
<p>In an episodic task, the on-policy distribution depends on how the initial states of the episodes are chosen. Let \(h(s)\) be the starting state distribution,</p>
<p>\begin{align*}
\eta(s) &amp;= h(s) + \sum_{\bar{s}} \eta(\bar{s}) \sum_{a} \pi(a|\bar{s}) p(s|\bar{s}, a) \\\<br>
\mu(s) &amp;= \frac{\eta(s)}{\sum_{s&rsquo;} \eta(s&rsquo;)}, \text{ for all } s\in\states
\end{align*}</p>
<p>When there is discounting, \(\gamma\) can be included in the second term of \(\eta(s)\).</p>
</div>
<h3 id="stochastic-gradient-and-semi-gradient-methods">Stochastic-gradient and Semi-gradient Methods</h3>
<p>This is a pretty straightforward derivation of gradient Monte Carlo and semi-gradient TD(0).</p>
<div class="algorithm">
  <div></div>
<p>\begin{algorithmic}
\Require the policy $\pi$ to be evaluated
\Require a differentiable function $\hat{v}: \states \times \reals^d \rightarrow \reals$ \\\<br>
\Comment step size $\alpha &gt; 0$\\\<br>
\Comment Initialize value-function weights $\wvec\in\reals^d$ arbitrarily
\Loop forever (for each episode)
\State Generate an episode using $\pi$
\For{each step of episode}
\State $\wvec \leftarrow \wvec + \alpha [G_t - \hat{v}(S_t,\wvec)]\nabla \hat{v}(S_t, \wvec)$
\EndFor
\EndLoop
\end{algorithmic}</p>
<p>\caption{Gradient Monte Carlo Algorithm}</p>
</div>
<div class="algorithm">
  <div></div>
<p>\begin{algorithmic}
\Require the policy $\pi$ to be evaluated
\Require a differentiable function $\hat{v}: \states \times \reals^d \rightarrow \reals$ \\\<br>
\Comment step size $\alpha &gt; 0$\\\<br>
\Comment Initialize value-function weights $\wvec\in\reals^d$ arbitrarily
\Loop{forever (for each episode)}
\State Initialize S
\For{each step of episode}
\State Choose $A \sim \pi(\cdot|S)$
\State Take action $A$, observe $R, S'$
\State $\wvec \leftarrow \wvec + \alpha [R + \gamma\hat{v}(S&rsquo;, \wvec) - \hat{v}(S,\wvec)]\nabla \hat{v}(S_t, \wvec)$
\State $S \leftarrow S'$
\EndFor
\EndLoop
\end{algorithmic}</p>
<p>\caption{Semi-gradient TD(0) Algorithm}</p>
</div>
<h3 id="linear-methods">Linear Methods</h3>
<p>One special case of function approximation is where the approximate value is a linear function of the weight vector.</p>
<ul>
<li>\(\hat{v}(s, \wvec) =  \wvec^\trans x(s)\)</li>
<li>\(\nabla\hat{v}(s, \wvec) = x(s)\)</li>
</ul>
<p>\begin{equation}\label{eqn:RLI:linear-update}
\wvec_{t+1} = \wvec_t + \alpha [U_t - \hat{v}(S_t, \wvec_t)]x(S_t)
\end{equation}</p>
<p>Under linear function approximation the Monte Carlo algorithm presented above converges to the global optimum of the \(\overline{VE}\) objective under the normal constraints.</p>
<p>Semi-gradient TD(0) also converges, but to a local optimum. See the box for more details.</p>
<div class="tcolorbox">
  <div></div>
<p>We first need to rewrite the above update \ref{eqn:RLI:linear-update}</p>
<p>\[\wvec_{t+1} = \wvec_t + \alpha\left( R_{t+1} \xvec_t - \xvec_t(\xvec_t - \gamma\xvec_{t+1})^\trans \wvec_t \right)\]</p>
<p>Once the system reaches a steady state, the expected next weight vector can be written</p>
<p>\[\expected[\wvec_{t+1}|\wvec_t] = \wvec_t + \alpha(\bvec - \Amat\wvec_t)\]</p>
<p>where</p>
<p>\[\bvec \defeq \expected[R_{t+1}\xvec_t] \in \reals^d \text{ and } \Amat\defeq \expected\left[ \xvec_t(\xvec_t - \gamma \xvec_{t+1})^\trans\right]\in\reals^d\times\reals^d  \]</p>
<p>This system must then converge to (if it converges at all) \(\wvec_{TD} \defeq \Amat^\inv \bvec\).</p>
<p>What sorts of properties are required for convergence? By rewriting the expected next weight vector</p>
<p>\[\expected[\wvec_{t+1}|\wvec_t] = (\eye - \alpha\Amat)\wvec_t + \alpha\bvec\]</p>
<p>we can see that \(\Amat\) is the only important component for convergence. Consider a special case where \(\Amat\) is a diagonal matrix. If any of the components are negative, then the corresponding diagonal element of \(\eye - \alpha\Amat\) will be greater than one, and the corresponding component of \(\wvec_t\) will be amplified leading to divergence. In general, we can say \(\wvec_t\) will converge whenever \(\Amat\) is <em>positive definite</em> (i.e. \(y^\trans\Amat y\) for any \(y\neq 0\)). The rest of the proof follows once we know \(\Amat\) is <em>positive definite</em>.</p>
<p>We can rewrite this matrix:</p>
<p>\begin{align*}
\Amat
&amp;= \sum_s \mu(s) \sum_a \pi(a|s) \sum_{r,s&rsquo;} p(r, s'|s, a)\xvec(s)(\xvec(s) - \gamma \xvec(s&rsquo;))^\trans \\\<br>
&amp;= \sum_s \mu(s)\xvec(s) \left( \xvec(s) - \gamma \sum_{s&rsquo;} p(s'|s)\xvec(s&rsquo;) \right) \\\<br>
&amp;= \Xmat^\trans \Dmat (\eye - \gamma \Pmat)\Xmat
\end{align*}</p>
<p>From here, it is clear that the inner matrix is key to determining the positive definiteness of \(\Amat\). It has been shown prior that a matrix of this form is positive definite if all of its columns sum to a nonnegative number. See <a href="/braindump/sutton1988/">(Sutton 1988)</a> for a detailed proof. Also note that \(\muvec\), which is the \(|\states|\) vector of the \(\mu(s)\) distribution, is a stationary distribution thus \(\muvec = \Pmat^\trans\muvec\) The column sums of this matrix is then:</p>
<p>\begin{align*}
\mathbf{1}^\trans \Dmat(\eye - \gamma \Pmat)
&amp;= \muvec^\trans(\eye - \gamma \Pmat) \\\<br>
&amp;= \muvec^\trans - \gamma \muvec^\trans \Pmat \\\<br>
&amp;= (1-\gamma)\muvec^\trans
\end{align*}</p>
<p>All the components of \((1-\gamma)\muvec^\trans\) are positive, and therefore \(\Amat\) is positive definite, and TD(0) is stable.</p>
<p>It has also been shown at the TD fixed point that the \(\overline{VE}\) is within a bounded expansion of the lowest possible error.</p>
<p>\[\overline{VE}(\wvec_{TD}) \leq \frac{1}{1-\gamma} \min_{\wvec} \overline{VE}(\wvec)\]</p>
</div>
<div class="algorithm">
  <div></div>
<p>\begin{algorithmic}
\Require the policy $\pi$ to be evaluated
\Require a differentiable function $\hat{v}: \states \times \reals^d \rightarrow \reals$
\Require All store and access operations ($S_t$ and $R_t$) can take their index mod $n+1$ \\\<br>
\Comment step size $\alpha &gt; 0$\\\<br>
\Comment Initialize value-function weights $\wvec\in\reals^d$ arbitrarily
\For{each episode}
\State Initialize and store $S_0 \neq \text{terminal}$
\State $T \leftarrow \infty$
\Repeat
\If{t &lt; T}
\State Take an action according to $\pi(\cdot|S_t)$
\State Observe and store $R_{t+1}$ and $S_{t+1}$
\State If $S_{t+1}$ is terminal, then $T \leftarrow t+1$
\EndIf
\State $\tau \leftarrow t - n + 1$
\Comment $\tau$ is the time whose state&rsquo;s estimate is being updated
\If{$\tau \geq 0$}
\State $G \leftarrow \sum_{i=\tau+1}^{\min(\tau + n, T)} \gamma^{i-\tau-1} R_i$
\State If $\tau + n &lt; T$, then: $G \leftarrow G+\gamma^{n} \hat{v}(S_{\tau + n}, \wvec)$
\State $\wvec \leftarrow \wvec + \alpha [G - \hat{v}(S,\wvec)]\nabla \hat{v}(S_t, \wvec)$
\EndIf
\Until{$\tau = T-1$}
\EndFor
\end{algorithmic}</p>
<p>\caption{n-step Semi-gradient TD Algorithm}</p>
</div>
<h3 id="feature-construction-for-linear-methods">Feature Construction for Linear Methods</h3>
<p>This section is exactly what you would expect. It lays out a number of ways to construct features for a reinforcement learning agent.</p>
<!--list-separator-->
<ul>
<li>
<p>Polynomials</p>
<p>This is straightforward, and takes advantage of the Taylor series formulation. This formulation can represent highly-complex interactions among the problem&rsquo;s state dimensions.</p>
<p>Suppose each state s corresponds to k numbers, \(\{s_1, s_2, \ldots, s_k\}\), with each \(s_i \in \reals\). For a k-dimensional state space, each order-n polynomial-basis feature \(x_i\) can be written as:</p>
<p>\[x_i(s) = \prod_{j=1}^k s_j^{c_i,j} \text{ where } c_{i,j} \in \{0,1,\ldots,n\}\]</p>
<p>Just like a Taylor series, more polynomials will be more accurate at the cost of storing such order-n polynomial functions (which grow exponentially with \(k\)).</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Fourier Basis</p>
<p>This feature creation technique is based on the Fourier series. You can represent any <em>even</em> function, or a function which is symmetric about the origin with interval \([0,\tau/2]\), with only a cosine basis. You can represent an <em>odd</em> function with only sinusoidal basis. We focus on <em>even</em> functions here, setting \(\tau=2\) so the features are defined over the half-τ interval \([0,1]\). The one-dimensional order-n Fourier cosine basis is</p>
<p>\[x_i = cos(i\pi s), s\in[0,1], i = 0, \ldots, n\]</p>
<p>This can also be applied in the multi-dimensional state case as well, but not discussed in these notes (see <a href="/braindump/reinforcement_learning_an_introduction/">(Sutton 2018)</a> page 213).</p>
<p>If using a Fourier cosine feature creation method, it has been found useful to define a learning rate for each feature separately. (Konidaris 2011) suggest setting the learning rate parameter for features \(x_i\) to \(\alpha_i = \alpha/\sqrt{(c^i_1)^2 + \ldots + (c^i_k)^2}\).</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Coarse Coding</p>
<p>Coarse coding is a simple idea. The basic idea is to have a bunch of overlapping &ldquo;areas&rdquo; (or &ldquo;receptive fields&rdquo;), which correspond to features in a large binary feature vector. When a state is within a certain region, the feature is said to be <em>present</em> and has an active unit within the feature vector.</p>
<p><strong>Properties</strong>:</p>
<ul>
<li>If we train at one state, a point in the space, then the weights of all overlapping fields will be affected by a learning update. The approximate value function will be affected at all states within the union of the fields, with a greater effect the more circles a point has &ldquo;in common&rdquo; with the state.</li>
<li>If the RFs are small, the generalization will be over a short distance.</li>
<li>If the RFs are large, the generalization will be over a large distance.</li>
<li>The shape of the field will determine the nature of the generalization.</li>
<li>Features with large receptive fields give broad generalization, but might also seem to limit the learned function to a coarse approximation. This is not necessarily the case as initial generalization from one point to another is controlled by the size and shape of RFs, but acuity is controlled by the total number of overlapping features.</li>
</ul>
 <!--list-separator-->
<ul>
<li>
<p>Tile Coding</p>
<p>This is a simple form of coarse coding, which automatically creates a set of tilings. Each of which tile the space through state aggregation. The power comes in the off-set of the tilings, where this creates a number of overlapping (but not completely) RFs which can be used in learning.</p>
<p>I won&rsquo;t go into details here, but this is obviously one of Rich&rsquo;s favorites, as the explanation is long and much more complete as compared to other feature creating techniques. If you look at the results, the Fourier basis does surprisingly similar to the tile coding with 50 tilings in the simple example.</p>
</li>
</ul>
 <!--list-separator-->
<ul>
<li>
<p>Radial Basis Functions</p>
<p>Radial basis functions (RBFs) are a natural instantiation of coarse coding with continuous-valued features. Rather than a feature being 0 or 1, it can be anything in the interval representing the closeness to the center of a receptive field represented through a gaussian function. If the feature is 1 then the feature represents the &ldquo;center&rdquo; or &ldquo;prototype&rdquo; of the gaussian. This is similar to a kernel representation, although the kernel prototypes here are not not necessarily chosen through a principled algorithm. More on kernel-based function approximation below.</p>
</li>
</ul>
</li>
</ul>
<h3 id="selecting-step-size-parameters-manually">Selecting Step-Size Parameters Manually</h3>
<p>An ok rule of thumb is:</p>
<p>\[\alpha \defeq (\tau \expected[\xvec^\trans \xvec])^\inv\].</p>
<p>In coarse coding this simply resolves to
\[\alpha = \frac{1}{\tau \times \text{number of active features (tilings)}}\]</p>
<h3 id="nonlinear-function-approximation-artificial-neural-networks">Nonlinear Function Approximation: Artificial Neural Networks</h3>
<p>This is a straightforward treatment of ANNs, although this book is quite biased towards linear methods as exemplified by the sheer lack of details in this sections. There are many other books that go through these much clearer, specifically for RL ({Fran{\c c}ois-Lavet} 2018).</p>
<h3 id="least-squares-td">Least-Squares TD</h3>
<p>Least-squares TD is a straightforward algorithm which solves for the fixed point weights (i.e. \(\wvec_{TD} = \Amat^\inv \bvec\)) directly rather than through an iterative process. As a reminder</p>
<p>\[\bvec \defeq \expected[R_{t+1}\xvec_t] \in \reals^d
\quad \text{ and } \quad
\Amat \defeq \expected\left[ \xvec_t(\xvec_t - \gamma \xvec_{t+1})^\trans\right] \in \reals^d\times\reals^d  \]</p>
<p>which can be estimated relatively straightforwardly given a trajectory of data:</p>
<p>\begin{equation}
\widehat{\bvec}_{t} = \frac{1}{t}\sum_{k=0}^{t-1} R_{k+1} \xvec_{k}
\quad \text{ and } \quad
\widehat{\Amat}_{t} = \frac{1}{t}\sum_{k=0}^{t-1} \xvec_{k}\left(\xvec_{k}-\gamma \xvec_{k+1}\right)^{\top}+\varepsilon \mathbf{I}
\end{equation}</p>
<p>We can estimate just the sums, without taking average, as when creating the weight vector the average cancels out.</p>
<p>\[\wvec_t \defeq \widehat{\Amat}_t^\inv \widehat{\bvec}_t \]</p>
<p>The major computational component of this algorithm is the inverse of the matrix \(\widehat{\Amat}\). This can be side stepped through the Sherman-Morrison formula (see more details in the box).</p>
<p>\begin{equation}
\widehat{\Amat}_t^\inv =
\widehat{\Amat}_{t-1}^\inv -
\frac{\widehat{\Amat}_{t-1}^\inv \xvec_t(\xvec_t - \gamma \xvec_{t+1})^\trans \widehat{\Amat}_{t-1}^\inv}
{1 + (\xvec_t - \gamma\xvec_{t+1})^\trans \widehat{\Amat}_{t-1}^\inv \xvec_t}
\end{equation}</p>
<div class="tcolorbox">
  <div></div>
<p>\begin{theorem}
Suppose $\Amat \in \reals^{n \times n}$ is an /invertable square matrix/ and $\uvec, \vvec \in \reals^n$ are column vectors. Then $\Amat + \uvec\vvec^\trans$ is invertable iff $1 + \vvec^\trans\Amat^\inv\uvec \neq 0$. Specifically,</p>
<p>\[(\Amat + \uvec\vvec^\trans)^\inv = \Amat^\inv - \frac{A^\inv \uvec\vvec^\trans \Amat^\inv}{1+\vvec^\trans\Amat^\inv\uvec}\]</p>
<p>\end{theorem}</p>
<p>\begin{proof}</p>
<p>We prove this in the backward direction, and do this by verifing the properties of the inverse. Specifically ($\Xmat = (\Amat + \uvec\vvec^\trans)$),</p>
<p>\begin{align*}
\Xmat\Xmat^\inv
&amp;= (\Amat + \uvec\vvec^\trans)\left(\Amat^\inv - \frac{A^\inv \uvec\vvec^\trans \Amat^\inv}{1+\vvec^\trans\Amat^\inv\uvec} \right) \\\<br>
&amp;= \Amat\Amat^\inv + \uvec\vvec^\trans \Amat^\inv -
\frac{\Amat\Amat^\inv\uvec\vvec^\trans\Amat^\inv + \uvec\vvec^\trans\Amat^\inv\uvec\vvec^\trans\Amat^\inv}
{1 + \vvec^\trans\Amat^\inv\uvec} \\\<br>
&amp;= \eye + \uvec\vvec^\trans \Amat^\inv -
\frac{\uvec(1 + \vvec^\trans\Amat^\inv\uvec)\vvec^\trans\Amat^\inv}
{1 + \vvec^\trans\Amat^\inv\uvec} \\\<br>
&amp;= \eye + \uvec\vvec^\trans \Amat^\inv - \uvec\vvec^\trans \Amat^\inv
\hspace{1cm} \triangleright 1 + \vvec^\trans \Amat^\inv \uvec \in \reals, \neq 0 \\\<br>
&amp;= \eye
\end{align*}</p>
<p>Reciprocally, if $1 + \vvec^\trans \Amat^\inv \uvec = 0$, then $x=\Amat^\inv\uvec$, we can see $(\Amat + \uvec\vvec^\trans)x = 0$ and therefore $(\Amat + \uvec\vvec^\trans)$ has a non-trivial kernel and is therefore not invertible.</p>
<p>\href{https://en.wikipedia.org/wiki/Sherman–Morrison_formula}{wikipedia}</p>
<p>\end{proof}</p>
</div>
<h3 id="memory-based-function-approximation">Memory-based Function Approximation</h3>
<p>This approach does not update a parametric function towards some objective. Instead it stores examples of transitions/states and their corresponding value estimate. When a new state arrives the value is estimated through a set of examples which are similar to the state. This is sometimes called <em>lazy learning</em>.</p>
<p>Some approaches:</p>
<ul>
<li>Nearest neighbor</li>
<li>Weighted average</li>
<li>Locally weighted regression</li>
</ul>
<h3 id="kernel-based-function-approximation">Kernel-based Function Approximation</h3>
<p>This is the typical Kernel regression formulation.</p>
<h3 id="looking-deeper-at-on-policy-learning-interest-and-emphasis">Looking Deeper at On-policy Learning: Interest and Emphasis</h3>
<p>Instead of treating each state uniformly, we can also treat states according to some <em>interest</em> function \(I_t\) indicating the degree to which we are interested in accurately.</p>
<p>\begin{align*}
\wvec_{t+n} &amp;\defeq \wvec_{t+n-1} + \alpha M_t[G_{t:t+n} - \hat{v}(S_t, \wvec_{t+n-1})]\nabla \hat{v}(S_t, \wvec_{t+n-1}), 0\leq t &lt; T \\\<br>
M_t &amp;= I_t + \gamma^n M_{t-1}
\end{align*}</p>
<h2 id="chapter-10">Chapter 10</h2>
<h2 id="chapter-11">Chapter 11</h2>
<h2 id="span-classorg-todo-todo-todotodospan-eligibility-traces-secrlitraces"><span class="org-todo todo TODO">TODO</span> Eligibility Traces {#sec:RLI:traces}</h2>
<h2 id="policy-gradient-methods">Policy Gradient Methods</h2>
<p>This chapter considers policy gradient methods, or methods which search for the policy directly rather than through an <em>action-value methods</em>. The policy gradient methods directly parameterize a policy to select actions (either deterministically or through some stochastic process).</p>
<p>The notation is standard in this chapter:</p>
<ul>
<li>\(\thetavec \in \reals^{d&rsquo;}\) for the policy&rsquo;s parameter vector,</li>
<li>\(\pi(a|s,\thetavec) = \text{Pr}\{A_t=a | S_t=s, \thetavec=\theta\}\) for the probability that action a is taken at time t given the parameterization and state of the environment,</li>
<li>\(\wvec \in \reals^d\) is the value function parameterization where \(\hat{v}(s,\wvec)\) is the estimated value.</li>
</ul>
<p>The methods considered here look to maximize some performance measure \(J(\thetavec)\) with respect to the policy parameter through gradient ascent.</p>
<p>\[\Delta\thetavec = \alpha \nabla J(\thetavec_t) \approx \alpha \hat{\nabla J(\thetavec_t)}\]</p>
<p>where \(\hat{\nabla J(\thetavec_t)}\) is the stochastic estimate of the gradient wrt the objective and policy parameterization.</p>
<ul>
<li><em>Policy gradient method</em>: any method which directly parameterizes a policy and learns through maximizing some objective function.</li>
<li><em>actor-critic method</em>: A policy gradient method which also learns an estimate of the value function.</li>
</ul>
<p>The only requirement for a policy gradient method is \(\pi(a|s, \thetavec)\) must be continuous and differentiable wrt its parameters over all \(a\in\actions, s\in\states\). We also never want the policy to become deterministic!</p>
<h3 id="policy-approximation-and-its-advantages">Policy approximation and its advantages</h3>
<p>The most natural of parameterization is to form parameterized numerical preferences \(h(s,a,\thetavec)\in\reals\). The policy is then defined through the soft-max distribution called the <em>soft-max in action preferences</em>:</p>
<p>\[\pi(a|s, \thetavec) = \frac{e^(h(s,a,\thetavec))}{\sum_{a&rsquo;} h(s,a&rsquo;,\thetavec)}\].</p>
<p>Some advantages:</p>
<ul>
<li>The approximate policy can approach a deterministic policy (as opposed to something like ε-greedy).</li>
<li>Enables the selection of actions with arbitrary probabilities. In problems with significant function approximation, the best approximate policy may be stochastic (for example Poker).</li>
<li>The policy may be a simpler function to approximate as opposed to the value function.</li>
<li>The selection of a policy parameterization could be a good way of injecting prior knowledge about the desired form of the policy.</li>
</ul>
<h3 id="the-policy-gradient-theorem">The Policy Gradient Theorem</h3>
<p>With a continuous policy parameterization the action probabilities change smoothly as a function of the learned parameters! Because of this, much stronger theoretical guarantees are available for policy-gradient methods than for action-value methods.</p>
<p><strong>Episodic case:</strong>
The performance measure:
\[J(\thetavec) =  v_{\pi_{\thetavec}}(s_0)\]</p>
<p>The challenge in policy gradients is the performance depends of both the action selections and the distribution of states in which those selections are made. Unfortunately, both of these are affected by the policy parameter, which means a straightforward gradient estimate requires intimate knowledge of the state distribution induced by the current policy.</p>
<p>The policy gradient theorem for the episodic case establishes an expression for the gradient which does not depend on the state distribution.</p>
<p>\[\nabla J(\thetavec) \propto \sum_s \mu(s) \sum_a q_{\pi}(s,a) \nabla \pi(a|s,\thetavec)\]</p>
<p>The constant of proportionality is the average length of an episode.</p>
<h3 id="reinforce">REINFORCE</h3>
<p><strong>All-actions Method:</strong> The rhs of the policy gradient theorem is a sum over states weighted by how often the states occur under the target policy \(\pi\); if \(\pi\) is followed, then states will be encountered in these proportions, therefore</p>
<p>\[\nabla J(\thetavec) \propto \mathbb{E}_\pi \left[\sum_a q_{\pi}(S_t, a) \nabla \pi(a|S_t, \thetavec) \right]\]</p>
<p>We could stop here and instantiate stochastic gradient ascent here, where we approximate the value function. We can continue down the line of reasoning presented in the policy gradient theorem and remove the weighting of the policy and replace the value function with the return. This results in</p>
<p>\[\nabla J(\thetavec) \approx \mathbb{E}_\pi \left[ G_t \frac{\nabla \pi(A_t | S_t \thetavec)}{\pi(A_t | S_t \thetavec)} \right]\]</p>
<p>yielding the REINFORCE with Monte Carlo update (Williams 1992):</p>
<p>\[\Delta \theta_t = \alpha G_t \frac{\nabla \pi(A_t | S_t \thetavec)}{\pi(A_t | S_t \thetavec)} \]</p>
<p>We can change out the comparison of the action value to an arbitrary baseline b(s) resulting in an update</p>
<p>\[\Delta \theta_t = \alpha (G_t - b(S_t)) \frac{\nabla \pi(A_t | S_t \thetavec)}{\pi(A_t | S_t \thetavec)} \]</p>
<p>This baseline can be learned or set.</p>
<h3 id="actor-critic">Actor-critic</h3>
<p>We can use the same methods used for TD(0), Sarsa(0), and other algorithms for estimating the return and using it as a critic in the policy gradient framework.</p>
<p>\begin{align*}
\Delta \theta_t
&amp;= \alpha (G_{t:t+1} - \hat{v}(S_t|\wvec)) \frac{\nabla \pi(A_t | S_t \thetavec)}{\pi(A_t | S_t \thetavec)} \\\<br>
&amp;= \alpha (R_{t+1} + \gamma \hat{v}(S_{t+1}|\wvec) - \hat{v}(S_t|\wvec)) \frac{\nabla \pi(A_t | S_t \thetavec)}{\pi(A_t | S_t \thetavec)} \\\<br>
&amp;= \alpha \delta_t \frac{\nabla \pi(A_t | S_t \thetavec)}{\pi(A_t | S_t \thetavec)}
\end{align*}</p>
<p>This generalizations for n-step and λ-return methods is straightforward, and not specified in these notes. See page 332 of <a href="/braindump/reinforcement_learning_an_introduction/">(Sutton 2018)</a></p>
<h3 id="policy-gradient-for-continuing-problems">Policy Gradient for Continuing Problems</h3>
<p>The performance metric for the continuing problem is in terms of the average rate of reward per time step:</p>
<p>\[J(\thetavec) \defineq r(\pi) \defineq \lim_{h\rightarrow\infty} \frac{1}{h} \expected [R_t| S_0, A_{0:t-1} \sim \pi] \]</p>
<p>As in the episodic case, the policy gradient theorem results in a gradient equation which is devoid of the gradient of the stationary distribution, and is in fact the same as above.</p>
<h3 id="policy-parameterization-for-continuous-actions">Policy Parameterization for Continuous Actions</h3>
<p>We can parameterize the policy according to the parameters of a distribution, or other such approaches. This is pretty straightforward.</p>
<h2 id="chapter-14">Chapter 14</h2>
<h2 id="chapter-15">Chapter 15</h2>
<h2 id="chapter-16">Chapter 16</h2>
<h2 id="references">References</h2>
<p>(Singh 1996)  Satinder P. Singh and  Richard S. Sutton, <em>Reinforcement {{Learning}} with {{Replacing Eligibility Traces}}</em>, Machine Learning, , pp.  (1996). <nil>.</p>
<p>(Sutton 2018)  Richard S. Sutton and  Andrew G. Barto, <em>Reinforcement Learning: An Introduction</em>, (2018).</p>
<p>(Tesauro 1994)  Gerald Tesauro, <em>{{TD}}-{{Gammon}}, a {{Self}}-{{Teaching Backgammon Program}}, {{Achieves Master}}-{{Level Play}}</em>, Neural Computation, , pp.  (1994). <nil>.</p>
<p>(Sutton 1988)  Richard S. Sutton, <em>Learning to Predict by the Methods of Temporal Differences</em>, Machine Learning, , pp.  (1988). <nil>.</p>
<p>(Konidaris 2011)  George Konidaris;  Sarah Osentoski and  Philip Thomas, <em>Value {{Function Approximation}} in {{Reinforcement Learning Using}} the {{Fourier Basis}}</em>, Twenty-{{Fifth AAAI Conference}} on {{Artificial Intelligence}}(2011).</p>
<p>({Fran{\c c}ois-Lavet} 2018)  Vincent {Fran{\c c}ois-Lavet};  Peter Henderson;  Riashat Islam;  Marc G. Bellemare and  Joelle Pineau, <em>An {{Introduction}} to {{Deep Reinforcement Learning}}</em>, Foundations and Trends\textregistered{} in Machine Learning, , pp.  (2018). <nil>.</p>
<p>(Williams 1992)  Ronald J. Williams, <em>Simple {{Statistical Gradient}}-{{Following Algorithms}} for {{Connectionist Reinforcement Learning}}</em>, (1992).</p>

    </div>

    
    

    

    
    

    

    

    

  </div>
</article>

			</section>
		</div>
	</article>
</div> 


<div class="page_footer">
	<p>Copyright © 2020 Matthew Schlegel. All Rights Reserved. Powered by <a href="http://gohugo.io/">Hugo</a> and <a href="https://github.com/jhu247/minimal-academic">Minimal Academic</a>.</p>
</div>
    
    


  </body>
</html>
